<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>树论</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/my.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/atom-one-light.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- page 1 -->
				<section>
					<h1>树论</h1>
					<div id="my-info">
						<p>颜俊梁</p>
						<p>2017级 计算机科学与工程学院</p>
						<p>2019年2月26日</p>
					</div>
				</section>
				
				<!-- page 2 -->
				<section>
					<section>
						<h2>树</h2>
						<img src="https://github.com/yjl9903/Pictures/raw/master/Tree/tree.png" >
					</section>
					
					<!-- <section>
						<p>数据结构中的树...</p>
					</section> -->

					<section>
						<p>算法竞赛中的树...</p>
					</section>

					<section>
						<h3>主题</h3>
						<p>一般树上的算法和问题</p>
					</section>
				</section>

				<!-- page 3 -->
				<section>
					<section>
						<h2>树基础</h2>
						<p style="font-size: 36px;">一个没有固定根结点的树成为无根树 (unrooted tree)</p>
						<p style="font-size: 36px;">无根树指定一个结点为根形成有根树 (rooted tree)</p>
					</section>
					<section>
						<h3>无根树的等价定义</h3>
						<ol style="font-size: 28px;">
							<li>有 $n$ 个点 $n-1$ 条边的连通无向图</li>
							<li>无向无环的连通图</li>
							<li>任意两个结点之间有且仅有一条简单路径的无向图</li>
							<li>任何边均为桥的连通图</li>
							<li>没有环，且在任意不同两点间添加一条边之后所得图含唯一的一个环的图</li>
						</ol>
					</section>
					<section>
						<h3>有关树的定义</h3>
						<ol style="font-size: 28px">
							<li>森林 <strong>Forest</strong> ：每一个连通块都是树的图（一棵树也是一个森林)</li>
							<li>生成树 <strong>Spanning Tree</strong> ：一个连通无向图的生成子图，同时要求是树</li>
							<li>结点的深度 <strong>depth</strong> ：到根结点的路径上的边数</li>
							<li>树的高度 <strong>height</strong>：所有结点深度的最大值</li>
							<li>无根树的叶子 <strong>leaf node</strong> ：度数不超过 1 的结点</li>
							<li>有根树的叶子 <strong>leaf node</strong> ：没有子结点的结点</li>
						</ol>
					</section>
					<section>
						<h3>有根树的定义</h3>
						<div class="inline-box" style="height: 488px;">
							<div class="vertical-align-box"><ol style="font-size: 28px;">
								<li>父亲 <strong>parent node</strong></li>
								<li>祖先 <strong>ancestor</strong></li>
								<li>子结点 <strong>ancestor</strong></li>
								<li>兄弟 <strong>sibling</strong></li>
								<li>后代 <strong>sibling</strong></li>
								<li>子树 <strong>subtree</strong></li>
							</ol></div>
						</div>
						<img style="float: right;" src="https://github.com/yjl9903/Pictures/raw/master/Tree/tree-basic.png">
					</section>
					<section>
						<h4>特殊的树</h4>
						<div class="fragment" style="position: relative; padding-top: 40px;">
							<img src="https://github.com/yjl9903/Pictures/raw/master/Tree/chain.png">
							<p style="font-size: 24px; width: 100%; position: absolute; top: 0;">链 <strong>chain</strong></p>
						</div>
						<div class="fragment" style="position: relative; padding-top: 40px;">
							<p style="font-size: 24px; width: 100%; position: absolute; top: 0;">菊花 / 星星 <strong>star</strong></p>
							<img src="https://github.com/yjl9903/Pictures/raw/master/Tree/star.png">
						</div>
					</section>
				</section>

				<!-- page 4 -->
				<section>
					<section>
						<h2>树的实现</h2>
						<p class="fragment fade-in">一般树</p>
						<p class="fragment fade-in">$10^5$ 个结点</p>
						<p class="fragment fade-in">邻接表  <del> 邻接矩阵 </del></p>
					</section>
					<section>
						<h3>链式前向星</h3>
						<p>数据结构定义</p>
						<pre><code>struct edge {
  int to, nxt; // other information
} g[maxn * 2]; // 无向边
int head[maxn], tot;</code></pre>
						<p>加边</p>
						<pre><code>void adde(int u, int v) {
  g[++tot] = (edge){v, head[u]}; head[u] = tot;
}
adde(u, v); adde(v, u);</code></pre>
					</section>
					<section>
						<p>$dfs$ 遍历</p>
						<pre><code>void dfs(int u, int f) {
  // ...
  for (int i = head[u]; i; i = g[i].nxt) {
    int u = g[i].to;
    if (v == f) continue;
    // ...
    dfs(v, u);
    // ...
  }
  // ...
}
// 空结点：0，根：1
dfs(1, 0);</code></pre>
					</section>
					<section>
						<h3>vector</h3>
						<p>数据结构定义</p>
						<pre><code>vector&lt;int&gt; edge[maxn];
vector&lt;pair&lt;int,int&gt;&gt; edge[maxn];</code></pre>
						<p>加边</p>
						<pre><code>edge[u].push_back(v);
edge[v].push_back(u);</code></pre>
					</section>
					<section>
						<p>$dfs$ 遍历</p>
						<pre><code>void dfs(int u, int f) {
  // ...
  for (int& v: edge[u]) {
    if (v == f) continue;
	// ...
    dfs(v, u);
    // ...
  }
  // ...
}</code></pre>
					</section>
				</section>
				
				<!-- page 5 -->
				<section>
					<section>
						<h2>dfs 序</h2>
						<p>在 dfs 的过程中 进入每个结点的时间戳</p>
					</section>
					<section>
						<img src="https://github.com/yjl9903/Pictures/raw/master/Tree/dfsorder.png">
						<table>
							<tr>
								<td style="font-size: 28px;">时间戳</td>
								<td>1</td>
								<td>2</td>
								<td>3</td>
								<td>4</td>
								<td>5</td>
							</tr>
							<tr>
								<td style="font-size: 28px;">结点</td>
								<td>A</td>
								<td>B</td>
								<td>D</td>
								<td>E</td>
								<td>C</td>
							</tr>
						</table>
						<p class="content fragment fade-in">一棵子树内的所有结点是 dfs 序上的一段连续区间</p>
					</section>
					<section>
						<h3>参考代码</h3>
						<pre><code>int in[maxn], out[maxn], tot = 0;
void dfs(int u, int f) {
  in[u] = ++tot;
  for (int& v: edge[u]) {
    if (v == f) continue;
    dfs(v, u);
  }
  out[u] = tot;
}</code></pre>
					</section>
					<section data-markdown class="content align-left">
						<textarea data-template>
							给定一棵 $n$ 个结点的无根树。
							
							你现在要把它画在一个平面上，使得边不相交，并且所有点的坐标满足 $1\le x_i,y_i \le n$。

							其中 $1 \le n \le 1000$。
							
							来源：[CCPC-Wannafly Winter Camp Day5 (Div. 2) A. Cactus Draw](https://www.zhixincode.com/contest/23/problem/A?problem_id=326)
						</textarea>
					</section>
					<section>
						<img src="https://github.com/yjl9903/Pictures/raw/master/Tree/dfsorder2.png">
						<p>$(dfn[u],dep[u])$</p>
					</section>
				</section>

				<!-- page 7 -->
				<section>
					<section>
						<h3>dfs 序的重要性质</h3>
						<p class="content fragment fade-in">一棵子树内的所有结点是 dfs 序上的一段连续区间</p>
						<p class="content fragment fade-in">树 $\rightarrow$ 序列</p>
					</section>
					<section data-markdown class="content align-left">
						<textarea data-template>
							<h3 style="text-align: center;">经典问题</h3>

							给定一棵 $n$ 个点的有根树，每个点有一个权值，$q$ 次操作，有两种操作：
							
							1. 将 $u​$ 的子树内所有点的权值加 $x​$
							2. 询问 $u​$ 的子树内所有点的权值和
							
							其中 $1 \le n,q \le 10^5​$
						</textarea>
					</section>
					<section>
							<p class="content">记录每个点进栈时的时间戳 $in$ 和出栈时的时间戳 $out$</p>
							<p class="content fragment fade-in">一个点的子树内所有点对应 $dfs$ 序上 $in$ 到 $out$ 的连续区间</p>
							<p class="content fragment fade-in">于是，问题就是区间修改和区间查询，使用线段树不难解决。</p>
					</section>
					<!-- problem -->
					<section data-markdown class="content align-left">
						<textarea data-template>
							给定一棵 $n$ 个点以 $1$ 为根的有根树。
							
							保证每个结点的编号与其 $dfs$ 序的编号相同（每个点 $dfs$ 时都是按照儿子的编号大小顺序依次进行遍历）。
							
							$q$ 次询问在编号 $[l,r]$ 区间内距离 $v​$ 最近的叶子结点的距离。

							其中 $3 \le n \le 5 \cdot 10^5,1 \le q \le 5 \cdot 10^5$。
							
							来源：[Codeforces Global Round 1 F. Nearest Leaf](https://codeforces.com/contest/1110/problem/F)
						</textarea>
					</section>
					<section class="content page">
						<h2>Solution</h2>
						<p>离线所有询问到每个点上</p>
						<p class="fragment fade-in">动态维护一棵线段树表示所有点到当前 $dfs$ 的点的距离</p>
						<p class="fragment fade-in">$dfs$ 从根 $u$ 转移到儿子结点 $v$ 时</p>
						<p class="fragment fade-in"><strong>子树 $v$ 内</strong> 所有叶子的距离 <strong>减去</strong> 这条边的长度</p>
						<p class="fragment fade-in"><strong>子树 $v$ 外</strong> 所有叶子的距离 <strong>加上</strong> 这条边的长度</p>
					</section>
				</section>

				<!-- page 8 -->
				<section>
					<section data-markdown class="content align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个结点的有根树，维护两个操作

							1. 所有深度为 $l$ 的点权值加上 $x$
							2. 询问子树的权值和
							
							其中 $1\le n,q \le 10^5,1\le x\le10^9$。
							
							来源：[ACM-ICPC 2018 沈阳赛区网络赛 J. Ka Chang](https://nanti.jisuanke.com/t/A1998)
						</textarea>
					</section>
					<section class="content page">
						<h2>Solution</h2>
						<p>1. 树状数组维护 暴力修改所有深度为 $l​$ 的单点 时间复杂度：$O(n \log n) ​$</p>
						<p>2. 在深度 $l$ 上打标记 预处理 $dfs$ 序深度为 $d$ 的个数的前缀和  时空复杂度 $O(n^2)$ 单次询问复杂度 $O(n)$。</p>
						<p class="fragment fade-in">设定阈值 $T$ !</p>
						<p class="fragment fade-in">算法 $1$ 单次询问和修改: $O(T \log n)$</p>
						<p class="fragment fade-in">算法 $2$ 单次修改: $O(1)$, 单次询问: $O({n \over T})$</p>
						<p class="fragment fade-in">令 $T=\sqrt{{n\over \log n}}$</p>
						<p class="fragment fade-in">时间复杂度 $O(q\sqrt{n \log n}) $</p>
					</section>
					<section data-markdown class="content align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个结点的有根树
							
							有 $q$ 次操作，每次操作将结点 $u$ 的子树中，距离 $u$ 小于等于 $k$ （距离为路径上的边数）的子联通块中所有点权值加 $x$
							
							求 $q$ 次操作后每个点的权值

							其中 $1 \le n,q \le 3 \cdot 10^5,  1 \le k,x\le 10^9​$。

							来源：[Educational Codeforces Round 54  E. Vasya and a Tree](https://codeforces.com/contest/1076)
						</textarea>
					</section>
					<section class="content page">
						<h2>Solution</h2>
						<p>离线操作到每个结点上</p>
						<p class="fragment fade-in">每个结点的权值只和它的所有祖先上的操作有关</p>
						<p class="fragment fade-in">$dfs$ 时 栈中的结点就是当前遍历的点到根的路径</p>
						<p class="fragment fade-in">操作就是 $dep[u]$ 到 $dep[u]+k$ 这一段深度区间上加 $x$</p>
						<p class="fragment fade-in">单点查询某个点的权值 进出栈时用树状数组维护操作</p>
					</section>
					<!-- <section data-markdown class="content align-left">
						<textarea data-template>
							给定一棵 $n​$ 个结点带点权 $w_i​$ 的有根树
							
							将树划分成满足条件的垂直路径
							
							路径上的点数小于等于 $L​$ 点权和小于等于 $S​$
							
							垂直路径为一个结点序列 $v_1,v_2,\dots,v_k​$ 
							
							满足 $v_1$ 是 $v_2​$ 的父亲 $v_2$ 是 $v_3$ 的父亲 以此类推
							
							每个点都必须属于一个垂直路径内 求最少能分割成多少个这样的路径

							其中 $1 \le n \le 10^5,1\le w_i \le 10^9,1\le L \le 10^5,1\le S \le 10^{18}$。

							来源：[Codeforces Round #514 E. Split the Tree](https://codeforces.com/problemset/problem/1059/E)
						</textarea>
					</section> -->
					<!-- <section class="content page">
						<h2>Solution</h2>
						<p>每个叶子结点都必须在一个垂直路径中</p>
						<p class="fragment fade-in">贪心！</p>
						<p class="fragment fade-in">对于路径最底端的点 在满足限制的条件下要尽量往上爬</p>
						<p class="fragment fade-in">如果一个点 $u$ 的所有儿子都不能把某一条路径延伸到 $u$ 上 那么必须要从 $u$ 开始一条新的路径。</p>
						<p class="fragment fade-in">在 $dfs​$ 栈上维护前缀和 表示每个点到根的距离</p>
						<p class="fragment fade-in">在栈上二分找到深度最小的点 满足到当前点的路径上点权和小于等于 $S​$。</p>
					</section> -->
				</section>
				
				<!-- page 9 -->
				<section>
					<section>
						<h2>最近公共祖先</h2>
						<h3>LCA</h3>
						<p class="content fragment fade-in">公共祖先中深度最深的结点</p>
					</section>
					<section class="content">
						<p>$4$ 和 $11$ 的最近公共祖先为 $2$</p>
						<p>$12$ 和 $13$ 的最近公共祖先为 $12$</p>
						<img style="transform: translateY(-100px) scale(0.75);" src="https://github.com/yjl9903/Pictures/raw/master/Tree/hld.png">
					</section>
					<section class="content page">
						<h3>朴素算法</h3>
						<p class="fragment fade-in">将一个点往父亲跳到根 记录一下经过了哪些点</p>
						<p class="fragment fade-in">再把另外一个点往上跳 第一个相遇的点就是最近公共祖先</p>
						<p class="fragment fade-in">在一条链情况下 单次查询复杂度 $O(n)$</p>
					</section>
					<section class="content page">
						<h3>朴素算法</h3>
						<p class="fragment fade-in">先调整深度大的结点 令他们深度相同 因此他们到 $LCA$ 的距离相同</p>
						<p class="fragment fade-in">两个点一起往上跳 第一个相遇的点就是最近公共祖先</p>
						<p class="fragment fade-in">单次查询复杂度 $O(n)$</p>
					</section>
					<section class="content">
						<p class="fragment ">第一步将 $10$ 跳转到 $7$</p>
						<p class="fragment ">第二步 $7$ 和 $15$ 一起跳转到 $1$</p>
						<p class="fragment ">$10$ 和 $15$ 的最近公共祖先为 $1$</p>
						<img style="transform: translateY(-150px) scale(0.6);" src="https://github.com/yjl9903/Pictures/raw/master/Tree/bz.png">
					</section>
					<section class="content">
						<h3>倍增</h3>
						<p class="fragment">朴素算法的瓶颈在于如何快速地向根进行跳转</p>
						<p class="fragment">每个结点 $x​$ 的第 $2^i​$ 级祖先 <code>fa[x][i]</code></p>
						<p class="fragment">可以在 $O(\log h)​$ 的时间内将任意一个点往上跳 $h​$ 步</p>
					</section>
					<section class="content">
						<p>$h$ 拆成二进制数的位数是 $O(\log h)$ 的</p>
						<p class="fragment">例如 $h=(13)_{10}=(1101)_{2}$</p>
						<p class="fragment">这意味着我们需要将 $x$ 往上跳转 $2^0,2^2,2^3$ 次</p>
						<p class="fragment">$x \rightarrow fa[x][0]$</p>
						<p class="fragment">$x \rightarrow fa[x][2]​$</p>
						<p class="fragment">$x \rightarrow fa[x][3]​$</p>
					</section>
					<section class="content">
						<h3>询问 $u,v$ 的 $LCA$</h3>
						<ol>
							<li class="fragment">假设 $u$ 深度较大, $u$ 需要往上跳 $dep[u]-dep[v]$</li>
							<li class="fragment">若 $u,v$ 满足祖孙关系 则此时 $u,v$ 重合 返回 $u$ 或 $v$ 即可</li>
							<li class="fragment">二分找到最大的 $h$ 使得 $u,v$ 一起上跳 $h$ 步两点不重合</li>
							<li class="fragment">当前 $u,v$ 的父亲即为答案</li>
						</ol>
						<p class="fragment">单次询问的时间复杂度为 $O(\log n)$</p>
					</section>
					<section class="content">
						<h3>如何计算 <code>fa[x][i]</code></h3>
						<p class="fragment">dp!</p>
						<p class="fragment">预处理出每个点 $x$ 的父亲 即 <code>fa[x][0]</code></p>
						<p class="fragment">对于 $i > 0$, $fa[x][i]=fa[fa[x][i-1]][i-1]$</p>
						<p class="fragment">结点 $x​$ 的第 $2^i​$ 个祖先是 $x​$ 的第 $2^{i-1}​$ 个祖先的 $2^{i-1}​$ 个祖先</p>
						<p class="fragment">预处理的时间复杂度 $O(n \log n)$ 空间复杂度 $O(n \log n)$。</p>
					</section>
				</section>

				<!-- page 10 -->
				<section class="content">
					<section>
						<h2>应用</h2>
						<p>树上路径长度</p>
					</section>
					<section>
						<h3>前缀和思想</h3>
						<p class="fragment">如果预处理出所有 $\sum_{i=1}^k a_i(1\le k\le n)$</p>
						<p class="fragment">可以在 $O(1)$ 的时间内，回答任意一个区间的和 $\sum_{i=l}^r a_i=\sum_{i=1}^{r} a_i -\sum_{i=1}^{l-1}a_i​$</p> 
					</section>
					<section>
						<h3>放到树上</h3>
						<img style="transform: scale(0.75) translateY(-100px);" src="https://github.com/yjl9903/Pictures/raw/master/Tree/lcapath.png">
					</section>
					<section>
						<h3>放到树上</h3>
						<p class="fragment">$path(u,v)=path(root,u)+path(root,v)-2\cdot path(root,LCA(u,v))$</p>
						<p class="fragment">预处理所有点到根的距离</p>
						<p class="fragment">倍增找到 $LCA$</p>
						<p class="fragment">在 $O(\log n)$ 的时间内回答树上任意两点之间的距离</p>
					</section>
				</section>

				<!-- page 11 -->
				<section class="content">
					<section data-markdown class="align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个点 $n$ 条带边权的无向联通图
							
							有 $q$ 次操作
							
							修改一条边的边权和询问任意两点之间的最短路径长度

							其中 $1 \le n,q \le 10^5$。
							
							来源：[2018 HDu Multi-University Training Contest 7 H. Traffic Network in Numazu](http://acm.hdu.edu.cn/showproblem.php?pid=6393)
						</textarea>
					</section>
					<section class="align-left">
						<h3>Solution</h3>
						<p>$n$ 个点 $n$ 条边的无向连通图是在一棵树上加了一条环边</p>
						<p class="fragment">询问时 拆成两部分考虑 不走环边和走环边 取最小值</p>
						<p class="fragment">修改时 修改了这条边结点的子树内所有点到根的距离</p>
						<p class="fragment">树状数组维护区间加减 单点查询</p>
					</section>
					<section data-markdown class="align-left">
						<textarea data-template>
							<!-- problem -->
							给定一个 $n$ 个点 $m$ 条边的带边权无向连通图
							
							$q$ 次询问 $u$ 和 $v$ 之间的最短路径长度

							其中 $1 \le n,q \le 10^5,n-1\le m \le n+20$。

							来源：[Educational Codeforces Round 51 F. The Shortest Statement](https://codeforces.com/contest/1051/problem/F)
						</textarea>
					</section>
					<section class="page">
						<h3>Solution</h3>
						<p>$10^5$ 个点询问任意两点最短路，这可以做？</p>
						<p class="fragment">一个生成树的环边最多只有 $21$ 条</p>
						<p class="fragment">考虑将所有环边单独拿出来跑 $dijkstra$</p>
						<p class="fragment">树边使用 $LCA$ 差分进行计算</p>
						<p class="fragment">询问时 分成两类情况 只走树边和可以走环边 取最小值</p>
					</section>
					<section data-markdown class="align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个点带边权的无根树
							
							维护一个可以动态增加和删除结点的关键点集合
							
							询问使得当前的关键点集合连通的最小子连通块的边权和。

							其中 $1\le n,q \le 10^5$。

							来源：[Contest Hunter Round #56 C. 异象石](https://loj.ac/problem/10132)
						</textarea>
					</section>
					<section class="page">
						<h3>Solution</h3>
						<p>$3$ 个点怎么做？</p>
						<p class="fragment">不能随便选两个点算一次距离，再将 $LCA$ 和第三个点算一次距离</p>
						<p class="fragment">不难发现这个距离和的计算是与遍历点集的顺序有关的</p>
						<p class="fragment">$dfs$ 遍历一棵树的过程就是是沿着边走 每条边会在进出的时候经过两次</p>
						<p class="fragment">将关键点的集合按照 $dfs$ 序排序</p>
						<p class="fragment">这样从小到大遍历一趟实际上就是 $dfs$ 的过程</p>
						<p class="fragment">遍历过程中 计算相邻两个点的距离和 即是答案的两倍</p>
						<p class="fragment">加点和删点 只会影响该位置两边的距离 $set$ 维护即可</p>
					</section>
				</section>

				<!-- page 12 -->
				<section class="content">
					<section>
						<h2>应用</h2>
						<p>树上打标记差分</p>
					</section>
					<section>
						<h3>差分思想</h3>
						<p>树状数组维护序列 $a_i$ 支持单点更新和前缀和查询</p>
						<p>区间更新和单点查询？</p>
						<p class="fragment">树状数组内存的每个位置 $i$ 的定义变为 $a_i-a_{i-1}$</p>
						<p class="fragment">区间更新时 连续区间 $(l,r]$ 内的差值并没有变化</p>
						<p class="fragment">变化的只有 $l$ 位置和 $r+1$ 位置</p>
						<p class="fragment">在树上也可以做同样的事情去更新一条路径的权值</p>
						<p class="fragment">标记的定义是一个点和其儿子之间的差值 从叶子结点往根结点上传</p>
					</section>
				</section>

				<!-- page 13 -->
				<section class="content">
					<section data-markdown class="align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个点 $m$ 条边的无向联通图
							
							有 $n-1$ 条边是树边，剩余边是环边
							
							你现在需要斩断一条树边和一条环边，使得这张图不连通
							
							求有多少种切割方案

							其中 $1 \le n \le 10^5,1\le m \le 2 \cdot 10^5$。

							来源：[POJ 3417 Network](http://poj.org/problem?id=3417)
						</textarea>
					</section>
					<section class="page">
						<h3>Solution</h3>
						<p>有 $3$ 种情况</p>
						<div class="fragment">
							<p>1. 一条树边不在任何一个环内</p>
							<p>2. 一条树边仅在一个环内</p>
							<p>3. 一条树边在多个环内</p>
						</div>		
						<p class="fragment">统计一条边在多少个环内</p>
						<p class="fragment">在 $u​$ 和 $v​$ 上面打 $+1​$ 标记</p>
						<p class="fragment">在 $LCA(u,v)​$ 上打 $-2​$ 标记</p>
						<p class="fragment">遍历一遍这棵树 将标记从儿子结点不断上传合并</p>
					</section>
					<section data-markdown class="align-left">
						<textarea data-template>
							<!-- problem -->
							给定一棵 $n$ 个点带边权的有根树
							
							给定 $m$ 条树上路径
							
							要求将一条树边的权值置 $0$ 后 最小化所有路径长度的最大值

							其中 $1\le n, m \le 3 \cdot 10^5$。

							来源：[NOIP2015 D2T3 运输计划](https://www.luogu.org/problemnew/show/P2680)		
						</textarea>
					</section>
					<section class="page">
						<h3>Solution</h3>
						<p>二分答案</p>
						<p class="fragment">$check$ 能否构造出使得最大值为 $x$ 的方案</p>
						<p class="fragment">考虑将所有路径长度大于 $x$ 的路径端点打上标记</p>
						<p class="fragment">判断有没有一条边在所有长度大于 $x$ 的路径上，并且将其权值置 $0$ 后，可以使得这些路径权值都不大于于 $x​$</p>
					</section>
				</section>

				<!-- page 14 -->
				<section class="content">
					<section data-markdown class="align-left">
						<textarea data-template>
							给定一棵 $n$ 个点无根树
							
							有 $q​$ 次询问
							
							将无根树的根定为 $r​$，将给出的 $k​$ 个关键点划分为最多 $m​$ 块
							
							要求相同块内的点在这颗有根树上两两没有祖孙关系
							
							求分块的方案数

							其中 $1\le n,q\le 10^5,1\le k,r\le n,1\le m \le min(300,k)$ 
							
							且 $\sum k \le 10^5$。
								
							来源：[CodeCraft-19 and Codeforces Round #537 E. Tree](https://codeforces.com/contest/1111/problem/E)
						</textarea>
					</section>
					<section>
						<h3>第二类斯特林数</h3>
						<p>$S(n,m)$ 表示 $n$ 个不同的物品放入 $m$ 个相同的盒子内（盒子非空）的方案数</p>
						<p class="fragment">$$S(n,m)=S(n-1,m-1)+m\cdot S(n-1,m)$$</p>
					</section>
					<section class="page">
						<h3>Solution</h3>
						<p>第一部分转移不变，第二部分转移有限制</p>
						<p class="fragment">记 $h[i]$ 表示 $i$ 有多少个祖先在关键点的集合内</p>
						<p class="fragment">将关键点按照深度排序, 有转移方程</p>
						<p class="fragment">$dp[i][j]=dp[i-1][j-1]+(j-h[i])dp[i-1][j](h[i] < j) $</p>
					</section>
					<section class="page">
						<h3>如何求 $h[i]$</h3>
						<p class="fragment">考虑到换根操作 等价于求每个点到 $r$ 的路径上有多少个关键点</p>
						<p class="fragment">树状数组维护区间更新和单点查询</p>
					</section>
				</section>

				<!-- page 15 -->
				<section>
					<section class="content"><h2>树链剖分</h2></section>
					<section data-markdown class="content align-left">
						<textarea data-template>
							<h3 style="text-align: center;">经典问题</h3>

							给定一棵 $n$ 个点的无根树，有 $q$ 次操作

							1. 修改 **单个结点 / 树上两点之间的路径 / 一个结点的子树上** 的所有点的值。
							2. 查询 **单个结点 / 树上两点之间的路径 / 一个结点的子树上** 结点的值的 **和(其他支持线段树区间合并的信息)**。
							
							其中，点数 $2 \le n \le 10^5$，询问次数 $1 \le q \le 10^5​$。
						</textarea>
					</section>
					<section class="content page">
						<p>路径信息的维护 我们显然不可能每次暴力路径进行更新</p>
						<p class="fragment">类似于之前 $dfs​$ 序的思路，我们需要将树上的路径，转化为一些连续的区间</p>
						<p class="fragment">$dfs$ 序本身就将这棵树剖分成了一条条链，链上的标号是连续的</p>
					</section>
					<section>
						<img style="transform: scale(0.8) translateY(-50px);" src="https://github.com/yjl9903/Pictures/raw/master/Tree/hld2.png">
					</section>
					<section class="content page">
						<h3>处理路径操作</h3>
						<p class="fragment">剖分出链后，记录一下每个点所在链的链头 $top$</p>
						<p class="fragment">一条链上的点是连续的，链与链之前通过链头也可以快速跳转</p>
						<p class="fragment">$LCA$ 跳转时，每次选择链头深度深的点向上跳转</p>
						<p class="fragment">最终两个点会跳到一条链上</p>
						<p class="fragment">跳转过程中，使用线段树实现区间信息的维护</p>
					</section>
					<section>
						<h3>参考代码</h3>
						<pre><code>void solvePath(int u, int v) {
  while (top[u] != top[v]) { // 不在同一条链中
    if (dep[top[u]] < dep[top[v]]) swap(u, v); 
    // 将 u 设置为深度较深的那个
    // 线段树操作
    u = fa[top[u]];
  }
  // u, v 在同一条链中
  // LCA 为 u, v 中深度浅的那个
  // 线段树操作
}</code></pre>
					</section>
					<section class="content page">
						<h3>到此为止时间复杂度对嘛？</h3>
						<img class="fragment" src="https://github.com/yjl9903/Pictures/raw/master/Tree/hld3.png">
					</section>
					<section class="content page">
						<h3>轻重链剖分 <strong>Heavy path decomposition</strong>！</h3>
						<p class="fragment">如果我们预处理遍历时 选择子树结点个数最多的那个儿子放进同一条链内肯定会比较优</p>
						<p class="fragment">记 $son[u]$ 表示 $u$ 的所有儿子中，对应子树结点数最多的那个儿子，即重儿子。其余儿子均为轻儿子</p>
						<p class="fragment">重边为父结点连向重儿子的那条边，轻边为除了重边外的所有边</p>
						<p class="fragment">重链为重边组成的一条树链</p>
					</section>
					<section>
						<img style="transform: scale(0.8) translateY(-50px);" src="https://raw.githubusercontent.com/yjl9903/Pictures/master/Tree/hld4.png">
					</section>
					<section class="content page">
						<h3>性质 $1$</h3>
						<p>假设在以 $u$ 为根的子树中，$v$ 是 $u$ 的轻儿子，有 $size[v] \le {size[u] \over 2}$</p>
						<p class="fragment">如果 $size[v] > {size[u] \over 2}$，那么 $v$ 的大小将大于 $u$ 的其它所有子树大小之和，这与 $v$ 是 $u$ 的轻儿子矛盾。</p>
					</section>
					<section class="content page">
						<h3>性质 $2$</h3>
						<p>$u$ 到根路径上最多有 $O(\log n) $ 条重链或轻边</p>
						<div class="fragment">
							<p>从根结点到一个结点的路径上，每次经过一条轻边，子树大小将会至少缩小一半，因此这条路径上至多有 $\log n$ 条轻边。</p>
							<p>再考虑重链，因为重链一定是在路径的开始，结束位置或者两条轻边之间，所以重链的数量级是和轻边相同。</p>
							<p>因此 $u$ 到根的路径上最多只有 $O(\log n)$ 条重链或轻边。</p>
						</div>
					</section>
					<section class="content page">
						<h3>时间复杂度</h3>
						<p>按照轻重链对树进行剖分 那么对于任意一个点向上跳转的次数是 $O(\log n)​$</p>
						<p>算上线段树 时间复杂度为 $O(n+qn \log^2n)​$</p>
						<div class="fragment">
							<p>如果我们只是需要求 $LCA​$</p>
							<p>预处理的时间复杂度为 $O(n)​$ 单次询问的时间复杂度是 $O(\log n)​$</p>
						</div>
					</section>
					<section class="content">
						<h3>顺带一提</h3>
						<p class="fragment">长链剖分 $\rightarrow$ $O(1)$ 查询 $k$ 级祖先</p>
						<p class="fragment">虚实链剖分 $\rightarrow$ Link-Cut Tree</p>
					</section>
					<section data-markdown class="content page">
						<textarea data-template>
							给定一棵 $n$ 个点的有根树
							
							每个点一开始的颜色 $c_i$ 为 $0$
							
							现在有 $m$ 次操作，每次将 $u$ 到 $v$ 的路径上染上了颜色 $c$
							
							求每个点第 $k$ 次染的颜色是什么，若不足 $k$ 次，则输出 $0$。

							其中 $1 \le n,m,k \le 10^5, 1\le c_i \le 10^9$。
							
							来源：[牛客国庆集训派对 Day 6 I. 清明梦超能力者黄YY](https://ac.nowcoder.com/acm/contest/206/I)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p>修改操作是区间覆盖，肯定可以用线段树来做</p>
						<p class="fragment">第 $k$ 次前后的染色没有任何用</p>
						<p class="fragment">所以我们对我们每个区间维护一下染色次数的最小值和最大值</p>
						<p class="fragment">线段树更新操作时</p>
						<p class="fragment">如果当前区间最少已经更新了 $k$ 次 直接返回不进行更新</p>
						<p class="fragment">如果当前区间最大更新了不超过 $k-1$ 次 直接区间加一即可</p>
						<p class="fragment">当且仅当一个单点更新了 $k-1$ 次时才会为它染上颜色</p>
					</section>
				</section>

				<!-- page 16 -->
				<section data-markdown="" class="content">
					<textarea data-template>
						## 最近公共祖先

						| 算法            | 预处理复杂度  | 单次询问复杂度 |
						| :-------------- | :-----------: | :------------: |
						| 倍增            | $O(n \log n)$ |  $O(\log n)$   |
						| 转化为 RMQ 问题 | $O(n \log n)$ |     $O(1)$     |
						| 树链剖分        |    $O(n)$     |  $O(\log n)$   |

						Tarjan 离线算法 总体时间复杂度为 $O(n + q)$
					</textarea>
				</section>

				<!-- page 17 -->
				<section>
					<section class="content"><h2>树上启发式合并</h2><h3>DSU on Tree</h3><p class="fragment">小的集合合并到大的集合</p></section>
					<section data-markdown class="content page">
						<textarea data-template>
							给定一棵 $n$ 个点的有根树
							
							每个结点有一个颜色 $c_i​$
							
							询问每个点的子树内出现次数最多的颜色
							
							如果有多个颜色出现次数最多 输出这些颜色的编号和

							其中 $1 \le n,c_i \le 10^6​$

							来源：[Educational Codeforces Round 2 E. Lomsat gelral](https://codeforces.com/problemset/problem/600/E)
						</textarea>
					</section>
					<section class="content">
						<h3>假如数据范围缩小成 $1 \le n \le 1000$</h3>
						<p class="fragment">我会 $O(n^2)$!</p>
						<p class="fragment">遍历每个点 然后暴力这个点的子树 计算每个点的答案</p>
					</section>
					<section class="content page">
						<h3>怎么优化？</h3>
						<p class="fragment">考虑暴力的过程，我们显然希望从子树中保留一些信息回来</p>
						<p class="fragment">但是要保留所有子树的信息可能需要比较高级的数据结构</p>
						<p class="fragment">容易实现的是从某一个儿子上保留信息 再将其他儿子对应子树的信息合并</p>
					</section>
					<section class="content page">
						<h3>选哪个儿子？</h3>
						<p class="fragment">轻重链剖分！</p>
						<p class="fragment">选择重儿子！</p>
						<p class="fragment">任意一个点到根的路径上最多有 $\log n$ 条轻边</p>
						<p class="fragment">对于结点 $u$ 的所有祖先，如果其是一个轻儿子，那么 $u$ 就会被暴力更新一次</p>
						<p class="fragment">总体上时间复杂度为 $O(n \log n)$ 的（假设更新操作的复杂度是 $O(1)$）</p>
					</section>
				</section>

				<!-- page 18 -->
				<section>
					<section data-markdown class="content page">
						<textarea data-template>
							给定一个 $n$ 个点 $m$ 条边的任意无向图
							
							每个结点本身有一个颜色 $a_i$
							
							现在要给所有结点分别染色，要求一个联通块内结点必须染上相同的颜色
							
							分别询问每条边，删除这条边后，最多有多少结点染的颜色和其本身颜色相同

							其中 $1 \le n,m,a_i \le 10^5$。

							来源：[2018 ACM-ICPC Asia Qingdao Regional Contest B. Kawa Exam](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4059)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p>如果删的边在一个环内？</p>
						<p>如果删的边是一个桥边？</p>
						<p class="fragment">边双联通分量缩点得到一个森林</p>
						<p class="fragment">对于每条树边，计算子树内众数和子树外众数</p>
						<p class="fragment">需要一个 $O(1)$ 单点加减，$O(1)$ 查询全局最大值的数据结构？</p>
						<p class="fragment">修改都是 $+1​$ 或 $-1​$，维护每种出现次数的个数</p>
					</section>

					<section data-markdown class="content page">
						<textarea data-template>
							给定一棵 $n$ 个结点的有根树
							
							每条边有一个 $a$ 到 $v$ 的字母作为权值
							
							询问每个点的子树内最长的简单路径
							
							满足路径上边的字母可以打乱顺序拼成回文串。

							其中 $1 \le n \le 5\cdot 10^5$。

							来源：[Codeforces Round #383 (Div. 1) D. Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths](https://codeforces.com/contest/741/problem/D)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p class="fragment">一串字母能否拼成回文串的条件是最多只能有一个字母出现了奇数次</p>
						<p class="fragment">因此可以把这个状态压成 $bitmasks$</p>
						<p class="fragment">对于每一棵子树 $u$，遍历从 $u$ 开始的每条路径，维护每种串的最大深度</p>
						<p class="fragment">为了避免两种状态来源于同一个儿子</p>
						<p class="fragment">暴力子树信息后，先对这个儿子内每种状态询问 $23$ 次</p>
						<p class="fragment">（出现次数全部为偶数和 $22$ 种一个字母出现了奇数次）</p>
						<p class="fragment">$LCA​$ 差分得到路径长度，更新答案</p>
						<p class="fragment">当前儿子的信息与之前的信息合并起来</p>
					</section>
				</section>

				<!-- page 19 -->
				<section>
					<section data-markdown class="content page">
						<textarea data-template>
							给定一棵 $n$ 个点带边权的无根树
							
							要求在在树上选一些边，构成树上的正好 $m$ 条路径，每条边最多只能在一条路径中出现
							
							要求最大化每个选择方案中的最小路径长度

							其中 $1 \le n \le 5\cdot 10^4, 1 \le m \le n-1$。

							来源：[NOIP2018 D1T3 赛道修建](https://www.luogu.org/problemnew/show/P5021)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p class="fragment">二分答案 $check$ 能否构造出 $m$ 条路径 使得最小路径长度为 $mid$</p>
						<p class="fragment">如果树是一条链？</p>
						<p class="fragment">每次贪心地选长度恰好大于等于 $mid$ 的最短连续段</p>
						<p class="fragment">如果树是一棵菊花？</p>
						<p class="fragment">长度小于 $mid$ 的边去匹配一个最短的边，使得连起来长度大于等于 $mid$</p>
						<p class="fragment">一般树 做菊花树的匹配 最后将每个子树内最长路径回溯到父亲</p>
					</section>
				</section>

				<!-- page 20 -->
				<section>
					<section data-markdown class="content page">
						<textarea data-template>
							你有 $b$ 块钱去超市购物，现在超市有 $n$ 个物品
							
							每个物品有一个价格 $c_i$ ，使用优惠券能够优惠的价格 $d_i$
							
							优惠券不能直接使用，如果你要使用优惠券购买物品 $i$，就必须先用优惠券购买物品 $p_i$
							
							但是你可以直接用优惠券买 $1$ 号物品，保证依赖关系不成环
							
							求你最多能够购买多少件物品

							其中 $1 \le n \le 5000, 1\le b \le 10^9$。

							来源：[Codeforces Round #419 (Div. 1) C. Karen and Supermarket](https://codeforces.com/problemset/problem/815/C)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p>树形依赖背包</p>
						<p>背包容量很大，问题转化为买 $x​$ 件物品花的最少钱数</p>
					</section>
					<section class="content page">
						<h3>dp!</h3>
						<p class="fragment">记 $dp[u][m][2]$ 表示在子树 $u$ 内买 $m$ 件物品，结点 $u$ 是否使用优惠券，花的最少钱数</p>
						<div class="fragment">
							<p>初始状态</p>
							<p>$$dp[u][0][0]=0$$</p>
							<p>$$dp[u][1][0]=c_i$$</p>
							<p>$$dp[u][1][1]=c_i-d_i$$</p>
						</div>
						<p class="fragment">转移方程</p>
						<div class="fragment">
							<p>$$dp[u][i+j][0]=min(dp[u][i][0]+dp[v][j][0])$$</p>
							<p>$$dp[u][i+j][1]=min(dp[u][i][1]+dp[v][j][0])$$</p>
							<p>$$dp[u][i+j][1]=min(dp[u][i][1]+dp[v][j][1])$$</p>
						</div>
						<p class="fragment">每次转移的复杂度是 $O(n^2)$ 总体复杂度是 $O(n^3)$</p>
					</section>
					<section class="content page">
						<h3>怎么优化？</h3>
						<p class="fragment">如果子树大小比较小，不需要每次都跑 $O(n^2) $ 的转移</p>
						<p class="fragment">转移时 两次循环进行的次数与子树大小有关</p>
						<p class="fragment">假设我们在进行子树 $u$ 中的转移，当前已经遍历过 $v_1,v_2,\dots ,v_k$，此时最多有物品 $sum$ 个</p>
						<p class="fragment">$$sum=1+size(v_1)+size(v_2)+\dots+size(v_k)$$</p>
						<p class="fragment">转移 $v_{k+1}$ 时，$u$ 的状态只需要遍历 $sum$ 次，$v_{k+1} $ 的状态只需要遍历 $size(v_{k+1})$ 次</p>
						<p class="fragment">在子树 $u$ 的每次转移过程中 只两两合并了子树内 $LCA $ 为 $u$ 的点对状态</p>
						<p class="fragment">点对的总数为 $O(n^2)$ 总体时间复杂度为 $O(n^2)$</p>
					</section>
				</section>

				<!-- page 21 -->
				<section>
					<section data-markdown class="content page">
						<textarea data-template>
							给一棵有根树 $T=(V,E)​$
							
							$X​$ 是 $V​$ 的非空子集
							
							记 $f(X)​$ 表示 $T​$ 中包含点集 $X​$ 的最小联通块中的边数
							
							求

							$$
							\sum_{X\subseteq V,X \neq \varnothing} (f(X))^k
							$$
							
							其中 $2\le|V| \le 1e5,1\le k \le 200$ 。
							
							来源：[Codeforces Hello 2019 G. Vladislav and a Great Legend](https://codeforces.com/contest/1097/problem/G)
						</textarea>
					</section>
					<section class="content page">
						<h3>Solution</h3>
						<p class="fragment">$k=1$ 直接扫一遍算贡献即可</p>
						<p class="fragment">考虑 $k>1​$ 的情况，由第二类斯特林数展开</p>
						<p class="fragment">$$(f(X))^k=\sum_{i=0}^{k}S(k,i)i!{f(X) \choose i}$$</p>
					</section>
					<section class="content page">
						<p>前面一部分可以预处理，也就是要求对于 $i (0\le i \le k)$</p>
						<div class="fragment">
						<p>$$\sum_{X\subseteq V,X \neq \varnothing} {f(X) \choose i}$$</p>
						<p>设 $E' \subseteq E$ 且 $|E'|=i$，$E_X$ 为 $f(X)$ 对应联通块的边集，上式可以写成</p>
						<p>$$\sum_{X\subseteq V,X \neq \varnothing} \sum_{e_j \in E',1\le j \le i} [e_1,e_2,\dots,e_i \in E_X]$$</p>
						<p>于是，交换求和顺序</p>
						<p>$$\sum_{e_j \in E',1\le j \le i} \sum_{X\subseteq V,X \neq \varnothing} [e_1,e_2,\dots,e_i \in E_X]$$</p>
						<p>上式含义是枚举边集 $E$ 的大小为 $i$ 的子集 $E'$，计算 $E'$ 出现在多少个点集 $V$ 的非空子集 $X$ 对应的联通块内</p>
						</div>
					</section>
					<section class="content page">
						<h3>$dp$</h3>
						<p class="fragment">记 $dp[i][j]$ 表示以 $i$ 为根的子树内大小为 $j$ 的边集，在子树内对上式的贡献</p>
						<p class="fragment">设当前计算的根为 $u$，有三种情况：</p>
						<p class="fragment">1. $u$ 到子树的边单独构成边集</p>
						<p class="fragment">2. $u$ 到子树的边与这棵子树的边集合并</p>
						<p class="fragment">3. $u$ 的子树的边集之间合并，子树的边集包含前两种情况</p>
						<p class="fragment">转移就是所有子树的 $dp$ 状态做卷积，并将子树状态更新进答案</p>
						<p class="fragment">考虑类似于树形依赖背包的优化方式，最终时间复杂度为 $O(nk)$</p>
					</section>
				</section>

				<!-- page 22 -->
				<section class="content">
					<section>
						<h3>最后</h3>
						<p>希望对各位有所帮助，谢谢！</p>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				math: {
					mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'
				},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
			Reveal.configure({
				keyboard: {
					13: 'next',
					32: 'next',
					8: 'prev',
				}
			});
		</script>
	</body>
</html>
